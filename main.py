import cv2                      # Подключаем OpenCV — основную библиотеку для работы с изображениями
import numpy as np              # Подключаем NumPy — для создания и работы с матрицами

# === ШАГ 1: ЗАГРУЖАЕМ ИЗОБРАЖЕНИЕ ===

img = cv2.imread('py/1.jpg')    # Загружаем картинку из файла. Она будет считана как матрица BGR (цветная)

# === ШАГ 2: УМЕНЬШАЕМ РАЗМЕР ===

# Иногда изображение слишком большое — уменьшим его в 2 раза, чтобы быстрее обрабатывать
img = cv2.resize(
    img,
    (img.shape[1] // 2, img.shape[0] // 2)  # Новый размер: ширина и высота, делим на 2
)

# === ШАГ 3: РАЗМЫТИЕ ===

# Размытие помогает убрать мелкие шумы и помехи перед обработкой
# 9x9 — размер окна размытия (должен быть нечётный)
img = cv2.GaussianBlur(img, (9, 9), 0)

# === ШАГ 4: ПЕРЕВОД В ОТТЕНКИ СЕРОГО ===

# Работа с одним каналом проще (серый), чем с тремя (цвет)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# === ШАГ 5: ПОИСК КОНТУРОВ ===

# Canny ищет резкие изменения яркости — это обычно границы объектов
# 100 — нижний порог, 150 — верхний. Чем выше значения, тем меньше деталей.
edges = cv2.Canny(gray, 100, 150)

# === ШАГ 6: УТОЛЩАЕМ КОНТУРЫ ===

# Создаём матрицу 5x5, заполненную единицами — ядро для обработки
kernel = np.ones((5, 5), np.uint8)

# Расширение (dilate) делает белые области больше — контуры становятся толще
dilated = cv2.dilate(edges, kernel, iterations=1)

# === ШАГ 7: СЖИМАЕМ КОНТУРЫ ===

# Сжатие (erode) — обратная операция, возвращает форму после dilate и убирает шум
eroded = cv2.erode(dilated, kernel, iterations=1)

# === ШАГ 8: ВЫВОД РЕЗУЛЬТАТА ===

cv2.imshow('Final Result', eroded)  # Показываем итоговое изображение в отдельном окне
cv2.waitKey(0)                      # Ожидаем нажатие любой клавиши
cv2.destroyAllWindows()            # Закрываем все окна
